## onSaveInstanceState和onRestoreInstanceState ##

- onSaveInstanceState()和onRestoreInstanceState()并不是生命周期中的方法，它们不一定会被触发，当遇到意外的情况，如内存不足，用户直接按Home键的时候，由系统销毁一个Activity的时候，onSaveInstanceState()会被调用，但是如果用户主动的去销毁一个Activity(例如按下back)等，onSaveInstanceState则不会被调用。

- onSaveInstanceState:在Activity被杀掉之前调用保存每个实例的状态，以保证该状态可以在onCreate(Bundle),onRestoreInstanceState(Bundle)传入Bundle的参数已经被onSaveInstanceState封装好的。
 
- onRestoreInstanceState:其与onSaveInstanceState不一定是成对的被调用，在Bundle中通过getParcelable方法得到Parcelable对象，然后把该Parcelable对象传递给View的onRestoreInstanceState(Parcelable state).onRestoreInstanceState()在onStart() 和 onPostCreate(Bundle)之间调用。

- Activity之间的跳转操作，其中有一些是为了获得系统中的资源或是一些必要信息，而一般是通过启动Activity(常用startActivity()和startActivityForResult()函数)来进行操作。在这个跳转的期间，我们当前的Activity暂时失去了焦点，处于不可操作状态，可在此之前先通过onSaveInstanceState()方法来保存一些暂时时的数据。当回到先前的Activity时，先前的Activity重新获取了焦点，系统就是触发onRestoreInstanceState()方法，可获取失去焦点前的一些数据。onRetainNonConfigurationInstance()方法也具有类似的功能来处理这样的数据操作。

- onRetainNonConfigurationInstance()方法主要是用于屏幕的旋转操作。onSaveInstanceState()和onRetainNonConfigurationInstance()都可以实现保存数据的功能，如果是两个同时使用时，执行顺序是哪个在先，哪个在后呢？

		根据Android官方网站上介绍，如果两个方法同时出现时，onSaveInstanceState()方法执行在先，而onRetainNonConfigurationInstance()方法执行在后。它们的执行顺序都在onStop()和onDestroy()之间。


- 保存原理：onSaveInstanceState ()，是在函数里面保存一些View有用的数据到一个Parcelable对象并返回。在Activity的onSaveInstanceState(Bundle outState)中调用View的onSaveInstanceState ()，返回Parcelable对象，

　　接着用Bundle的putParcelable方法保存在Bundle  savedInstanceState中。

　　当系统调用Activity的的onRestoreInstanceState(Bundle savedInstanceState)时， 同过Bundle的getParcelable方法得到Parcelable对象，然后把该Parcelable对象传给View的onRestoreInstanceState (Parcelable state)。在的View的onRestoreInstanceState中从Parcelable读取保存的数据以便View使用。