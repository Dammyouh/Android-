### 一、网路基础

1、常见的网络框架：一开始只是对于HttpClient和HttpUrlConnection建议封装的使用的工具类，到后来有Google开源的比较完善的Volley,再到如今比较流行的Okhttp,Retrofit。

### 二、计算机网络体系结构

##### 1、分层结构有几个不同的版本，OSI模型以及TCP/IP模型：实现物理传输介质--MAC地址--IP地址--端口号--获取到数据根据应用层协议解析数据最终实现了网络通信和数据传输

物理层 ：这一层就是最底层了，提供二进制流传输服务，也就是真正开始通过传输介质（有线、无线）开始进行数据的传输了。 

数据链路层（ARP层）：负责把IP地址解析为MAC地址，即硬件地址，这样就找到了对应的唯一的机器。 

网络层（IP层）： 这一层IP协议，以及一些路由选择协议等。所以这一层的制定了数据要传递到哪个IP地址，中间涉及到一些最优线路，路由选择算法等等。

运输层（TCP，UDP）： 运输层有TCP和UDP两种协议，分别对应可靠的运输和不可靠的运输。

- TCP：(质量）要提供可靠的运输，所以内部要解决如何建立连接，保证运输是可靠的不丢失数据。
- UDP:（流畅）画质可能不太好，但是流畅
- 这一层一般和Socket打交道，Socket是一组封装好的编程调用接口，通过它，我们就能操作TCP，UDP进行连接打交道。通常使用Socket进行连接建立的时候，一般都要指定端口号，所以这一层指定了把数据送到对应的端口号。

应用层（HTTP,FTP,DNS,SMTP):如http协议，定义了如何包装和解析数据，按照协议规定包装数据，如按照请求行，请求头，请求体包装，包装好数据后将数据传至运输层。



### 三、HTTP相关

1、Http是无状态，无连接的

- 无连接不是说不需要连接，Http协议只是一个应用层协议，最终还是要靠运输层的如TCP协议向上提供的服务进行连接。无连接的含义是http约定了每次连接只处理一个请求，一次请求完成后就断开连接，这样主要是为了缓解服务器的压力，减小连接对服务器资源的占用。
- 无状态指每个请求之间都是独立的，对于之前的请求事务都是没有记忆力的能力，所以就出现了像Cookie这种，用来保存一些状态的东西。

2、请求报文与响应请求

- 请求报文：

  - 请求行：请求方法post/get,请求路径Url,协议版本等
    - get请求会把请求参数都拼接在url的后面，最终显示在地址栏，而post则会把请求参数数据放进请求体中，不会在地址栏显示出来
    - get会有传递参数的长度限制问题
  - 请求头：即header,里面包含很多字段
  - 请求体：发送数据

- 响应报文：

  - 状态行：状态码如200，协议版本等

  - 响应头：即返回的header
  - 响应体：响应正文数据

3、http的缓存机制（http的缓存主要利用了header里的两个字段来控制）

Cache-control主要包含以及几个字段

- private:则只有客户端可以缓存
- public:客户端和代理服务器都可以缓存
- max-age:缓存的过期时间，则之后再请求，如果没有超过缓存失效的时间则可以直接使用缓存
- no-cache:需要使用对比缓存来验证缓存数据，无论max-age缓存是否有失效，还是需要发起一次请求服务器的请求，确认一下资源是否有更新，然后做对比，如果没有缓存则返回304，取本地缓存，如果有更新，则返回最新的资源。
- no-store:所有内存都不会进行缓存，这个字段打开，则不会进行缓存，也不会取缓存。

ETag: 即用来对比缓存，Etag是服务端资源的一个标识码

- 当客户端发送第一次请求时，服务端会下发当前请求资源的标识ETag,下次再次请求的时，客户端会通过header里的If-None-Match将这个标识ETag带上，服务端将客户端传来的ETag与最新的资源ETag做对比，如果一样则表示没有更新，返回304.

### 四、Cookie

- 用来在本地缓存记录一些状态，一个Cookie一般都包含domin所属域,path,Expires)服务器可以通过响应头里的set-cookies来将状态写入客户端的Cookie里。

  

### 五、Https(Https = Http  + Ssl)

- 主要原理就是利用了非对称加密算法，平常用的对称加密算法之所以不安全，是因为双方是统一的密钥进行加密解密的，只要双方任意一方泄露了密钥，那么其他人就可以利用密钥解密数据。

- 非对称加密算法安全的原因：公钥加密的信息只能用私钥解开，私钥加密的信息只能被公钥解开。

- 安全的流程：私钥只有服务器端自己知道，而公钥可以告知其他人，如可以把公钥传给客户端，这样客户端通过服务端传来的公钥来加密自己传输的数据，而服务端利用私钥就可以解密这个数据了。由于客户端这个公钥加密的数据只有私钥能解密，而这个私钥只有服务端有，所以数据传输就安全了。

  

### 六、Http 2.0:OK http支持配置使用Http2.0协议，Http2.0相对于Http1.x来说提升是巨大的：

- 二进制格式：Http1.x是文本格式，而Http2.0是二进制以帧为基础单位，是一个二进制协议。一帧中出了包含数据外同时还包含该帧的标识：Stream Identifier,即标识了该帧属于哪个request,使得网络传输变得十分灵活。
- 多路复用：原来http1.x一个连接一个请求的情况有比较大的局限性，也引发了很多问题，如建立多个连接的消耗以及效率问题。多个请求公用一个TCP连接，多个请求可以同时在这个TCP连接并发，一个是解决了建立多个TCP连接的消耗问题，一个解决了效率的问题。
- 多个请求可以在一个TCP连接上并发的原理：
  - 二进制分帧，因为每一帧都有一个身份标识，所以每个请求的不同帧可以并发的无序发送出去，在服务端会根据每一帧的身份标识，将其整理到对应的request.
  - header头部压缩：主要是通过压缩header来减少请求的大小，减少流量消耗，提高效率。因为之前存在一个问题是，每次请求都要带上header，而这个header中的数据通常是一层不变的。 
  - 支持服务端推送

### 七、TCP三次握手：面向连接，提供可靠的数据传输，在这一层通常是通过Socket Api来操作TCP，建立连接等等。

- 三次握手：
  - 第一次：客户端发送SNY = 1表示此次握手是请求建立连接的，然后seq生成一个客户端的随机数X
  - 第二次：服务端发送SNY = 1，ACK = 1表示是回复请求建立连接的，然后ACK = 客户端seq + 1(这样客户端收到后就能确认是之前想要连接的那个服务端)，然后把服务端也生成一个代表自己的随机数seq = Y 发送给客户端。
  - 第三次：ACK = 1。seq = 客户端随机数 + 1，ack = 服务端随机数 + 1（这样服务端就能知道是刚刚那个客户端了）
- 为什么要建立三次握手：
  - 第三次握手是为了防止已经失效的请求连接请求报文段突然又传到服务器，因而产生错误
  - 场景：
    - C 端发出去的第一个网络连接请求由于某些原因在网络节点中滞留了，导致延迟，知道连接释放的某个时间点才到达S端，这是一个早已失效的报文，但是此时S 端仍然认为这是C 端建立连接的请求的第一次握手，于是S端回应了C 端，第二次握手。则此时已经建立连接了，但是此时C 端并没有任何数据要发送，则S 端就会傻傻的等待着，造成很大的资源浪费，所以需要第三次握手，只有C 端再次回应，就可以避免这种情况。

### 八、TCP 四次挥手断开连接

1、实现方式：

- 主动方：发送Fin+Ack报文，并置发送序号为X
- 被动方：发送Ack报文，并置发送序号为Z,再确认序号为X+1
- 被动方：发送Fin + Ack报文，并置发送序号为Y,再确认序号为X
- 主动方：发送ack报文，并置发送序号为X,再确认序号为Y

2、为什么比建立连接时多了一次握手：

- 服务端的ACK（回复客户端）和Fin(终止)消息并不是同时发生的，而是先ACK，然后再FIN。主要原因是：当客户端要求断开连接时，此时服务端可能还有未发送完的数据，所以先ACK，然后等数据发送完再FIN。这样就变成了四次握手了。

  

### 九、滑动窗口协议

- TCP的最主要的特点就是提供可靠的运输，其可靠运输的内部原理就是滑动窗口协议。
- 滑动窗口协议是保证TCP可靠传输的根本，因为发送窗口只有收到确认帧才会向后移动窗口继续发送其他帧。
- 根据发送窗口和接受窗口大小的不同设定就延伸了不同的协议：
  - 停止-等待协议：每发一帧都要等到确认消息才能发送下一帧，缺点：效率较差。
  - 后退N帧协议：采取累计确认的方式。接收方正确的接受N帧后发一个累计确认消息给发送窗口，确认N帧已正确收到，如果发送方规定时间内未收到确认消息则认为超时或数据丢失，则会重新发送确认帧之后的所有帧。缺点：出错序号后面的PDU已经发送过了，但是还是要重新发送，比较浪费。
  - 选择重传协议:若出现差错，只重新传输出现差错涉及需要的PDU,提高了传输效率，减少不必要的重传。 

### 十、流量控制和拥塞控制

- 流量控制：对一条通信路径上的流量进行控制，就是发送方通过获取接受方的回馈来动态调整发送的速率，来达到控制流量的效果。其目的是保证发送者的发送速度不超过接受者的接受速度。
- 拥塞控制：对整个通信子网的流量进行控制，属于全局控制。
  - 慢开始 + 拥塞
  - 快重传 + 快恢复

### 十一、Socket

- Socket是一组操作TCP、UDP的API，像HttpURLConnection和Okhttp这种涉及比较底层的网络请求发送的，最终当然也是通过Socket来进行网络请求连接的。